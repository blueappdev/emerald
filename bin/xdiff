#!/usr/bin/python3
#
# xdiff
#

import os
import sys
import string
import getopt
import time
import tkinter as tk
import tkinter.simpledialog

def warn(*arguments):
    print(*arguments, file=sys.stderr)

def error(*arguments):
    warn(*arguments)
    sys.exit(2)

class MessageDialog(tk.simpledialog.Dialog):
    def  __init__(self, parent, title = "titleString", text="messageString"):
        self.titleString = title
        self.messageString = text
        tk.simpledialog.Dialog.__init__(self,parent)

    def buttonbox(self):
        box = tk.Frame(self)
        self.button = tk.Button(box,
                text = "OK", width = 10,
                command = self.ok, default = tk.ACTIVE)
        self.button.pack(side = tk.LEFT, padx = 5, pady = 5)
        self.bind("<Return>", self.ok)
        self.bind("<Escape>", self.ok)
        box.pack()

    def body(self, master):
        self.title(self.titleString)
        #self.messageLabel = tk.Label(master, width = 16, text = self.messageString)
        self.messageLabel = tk.Label(master, text = self.messageString)
        #self.messageLabel.grid(row = 0, column = 1, stick = tk.W)
        self.messageLabel.grid()
        return None # self.button # for focus_set

class FindDialog(tk.simpledialog.Dialog):
    def __init__(self,parent,defaultFindString = ""):
        self.defaultFindString = defaultFindString
        tk.simpledialog.Dialog.__init__(self,parent)

    def body(self, master):
        self.title("Find")
        self.findString = None
        self.findStringVar = tk.StringVar()
        if self.defaultFindString is None:
            self.findStringVar.set("")
        else:
            self.findStringVar.set(self.defaultFindString)
        tk.Label(master,text="Find:").grid(
            row=0, column=0,
            stick=tk.W)
        self.entry = tk.Entry(master,textvariable = self.findStringVar,
            background = "white")
        self.entry.grid(row=0, column=1,
            columnspan=4, stick=tk.EW)
        self.entry.selection_range(0,tk.END)
        self.entry.icursor(tk.END)
        self.findInWhatWindow = tk.StringVar()
        self.findInWhatWindow.set("left")
        self.findDirection = tk.IntVar()
        self.findDirection.set(1)
        self.findIgnoreCase = tk.IntVar()
        self.findIgnoreCase.set(1)
        rb = tk.Radiobutton(master,
                text = "Forward",
                variable = self.findDirection,
                value = 1)
        rb.grid(row = 1, column = 1, stick = tk.W)
        rb = tk.Radiobutton(master,
                text = "Backward",
                variable = self.findDirection,
                value = -1)
        rb.grid(row = 2, column = 1, stick = tk.W)
        rb = tk.Checkbutton(master,
                text = "Ignore Case",
                variable = self.findIgnoreCase)
        rb.grid(row = 1,column = 2, stick = tk.W)
        rb = tk.Radiobutton(master,
                text = "Left Window",
                variable = self.findInWhatWindow,
                value = "left")
        rb.grid(row = 1, column = 3, stick = tk.W)
        rb=tk.Radiobutton(master,
                text="Right Window",
                variable=self.findInWhatWindow,
                value="right")
        rb.grid(row=2,column=3,stick=tk.W)
        return self.entry #for focus_set

    def apply(self):
        self.findString=self.entry.get()


class DiffViewer(tk.Frame):
    def __init__(self, master):
        self.createPopupMenus()
        self.horizontalScrollbarUpdateInfo=10
        self.verticalScrollbarUpdateInfo=10
        self.findString=None
        self.navigationList=[]
        self.navigationIndex=None
        tk.Frame.__init__(self, master=master)
        self.master.protocol("WM_DELETE_WINDOW", self.onFileExit)

        # Send explicitly the unpost context menu,
        # whenever the mouse button is pressed
        # (The context menu does not disappear on Unix,
        # when clicked outside the context menu.)
        self.master.bind("<Button-1>", self.unpostContextMenus)

        self.pack()
        self.createMenubar()
        self.createToolbar()
        self.createStatusLine()

        self.mainFrame=tk.Frame(self.master, width=1500, height=1100)
        self.master.bind("<Control-f>", self.onViewFind)
        self.master.bind("<F3>", self.onViewFindAgain)

        #
        # Left Frame
        #
        self.leftFrame = tk.Frame(self.mainFrame)
        self.leftLabel = tk.Entry(self.leftFrame, bd=1, relief=tk.SUNKEN)
        self.leftLabel.pack(side=tk.TOP,fill=tk.X)
        self.leftVerticalScrollbar=tk.Scrollbar(self.leftFrame,
                orient = tk.VERTICAL)
        self.leftHorizontalScrollbar=tk.Scrollbar(self.leftFrame,
                orient = tk.HORIZONTAL)
        self.leftText = tk.Text(self.leftFrame,
                bg="white",
                xscrollcommand=self.leftxset,
                yscrollcommand=self.leftyset)
        if os.name == "nt":
            self.leftText.config(font=("Courier",8))
        self.leftText.config(wrap=tk.NONE)
        self.leftVerticalScrollbar.pack(side=tk.RIGHT,fill=tk.Y)
        self.leftHorizontalScrollbar.pack(side=tk.BOTTOM,fill=tk.X)
        self.leftText.pack(fill=tk.BOTH,expand=1)
        #self.leftFrame.pack(side=tk.LEFT,fill=tk.BOTH,expand=1)
        #self.leftFrame.grid(row=0,column=0,stick=tk.NSEW,expand=1)
        self.leftFrame.place(relwidth=0.5,width=-7,relheight=1)

        self.leftText.bind("<Key>", self.filterKey)
        self.leftText.bind("<Button-3>", self.popupLeftMenu)
        self.leftLabel.bind("<Key>", self.filterKey)
        self.leftLabel.bind("<Button-3>", self.popupLeftMenu)

        #
        # Right Frame
        #
        self.rightFrame = tk.Frame(self.mainFrame)
        self.rightLabel = tk.Entry(self.rightFrame, bd = 1, relief = tk.SUNKEN)
        self.rightLabel.pack(side = tk.TOP, fill = tk.X)
        self.rightVerticalScrollbar = tk.Scrollbar(self.rightFrame,
                orient = tk.VERTICAL)
        self.rightHorizontalScrollbar = tk.Scrollbar(self.rightFrame,
                orient = tk.HORIZONTAL)
        self.rightText = tk.Text(self.rightFrame,
                bg="white",
                xscrollcommand = self.rightxset,
                yscrollcommand = self.rightyset)
        if os.name == "nt":
            self.rightText.config(font=("Courier",8))
        self.rightText.config(wrap=tk.NONE)
        self.rightVerticalScrollbar.pack(side=tk.RIGHT,fill=tk.Y)
        self.rightHorizontalScrollbar.pack(side=tk.BOTTOM,fill=tk.X)
        self.rightText.pack(fill=tk.BOTH,expand=1)
        #self.rightFrame.pack(side=tk.LEFT,fill=tk.BOTH,expand=1)
        #self.rightFrame.grid(row=0,column=1,stick=tk.NSEW,expand=1)
        self.rightFrame.place(relx=0.5,x=-7,width=-7,relwidth=0.5,relheight=1)

        self.rightText.bind("<Key>", self.filterKey)
        self.rightText.bind("<Button-3>", self.popupRightMenu)
        self.rightLabel.bind("<Key>", self.filterKey)
        self.rightLabel.bind("<Button-3>", self.popupRightMenu)

        # connect scrollbars with widgets
        self.leftVerticalScrollbar.config(command=self.yview)
        self.leftHorizontalScrollbar.config(command=self.xview)
        self.rightVerticalScrollbar.config(command=self.yview)
        self.rightHorizontalScrollbar.config(command=self.xview)

        self.canvas=tk.Canvas(self.mainFrame,background="white")
        self.canvas.place(relx=1,x=-14,width=14,relheight=1,height=-52,y=35)
        self.canvas.place(relx=1,x=-14,width=14,relheight=1,height=-52,y=35)
        self.canvas.bind("<Configure>", self.canvasChanged)

        #
        self.mainFrame.pack(fill=tk.BOTH,expand=1)

    def canvasChanged(self,event):
        # canvas size changed, re-paint all rectangles
        self.canvas.delete(tk.ALL)
        a = 0  # cumulation of lines
        b = 0
        leftdelta=0
        rightdelta=0
        for t,lefta,leftb,righta,rightb in self.diffRecords:
            assert(self.leftText.index(tk.END) == self.rightText.index(tk.END))
            x,y=map(int, self.leftText.index(tk.END).split("."))
            a=max(lefta+leftdelta,righta+rightdelta)
            b=a+max(leftb-lefta,rightb-righta)+1
            #print t,lefta,"(",lefta+leftdelta,")",leftb,righta,"(",righta+rightdelta,")",rightb,a,b
            if t=="a":
                self.canvas.create_rectangle(0,(a-1)*event.height/x,14,(b-1)*event.height/x,fill="red",outline="red")
                leftdelta=leftdelta + rightb - righta + 1
            if t=="d":
                self.canvas.create_rectangle(0,(a-1)*event.height/x,14,(b-1)*event.height/x,fill="green",outline="green")
                rightdelta=rightdelta + leftb - lefta + 1
            if t=="c":
                self.canvas.create_rectangle(0,(a-1)*event.height/x,14,(b-1)*event.height/x,fill="blue",outline="blue")
                d=(leftb - lefta) - (rightb - righta)
                if d<0:
                    leftdelta=leftdelta + abs(d) + 1
                if d>0:
                    rightdelta=rightdelta + abs(d) + 1


    def leftxset(self,a,b):
        if self.horizontalScrollbarUpdateInfo==40:
            self.horizontalScrollbarUpdateInfo=0
            self.leftHorizontalScrollbar.set(a,b)
            self.rightHorizontalScrollbar.set(a,b)
        elif self.horizontalScrollbarUpdateInfo==0:
            pass
        elif self.horizontalScrollbarUpdateInfo==20:
            self.leftHorizontalScrollbar.set(a,b)
            self.rightHorizontalScrollbar.set(a,b)
        elif self.horizontalScrollbarUpdateInfo==10:
            self.horizontalScrollbarUpdateInfo=0
            self.leftHorizontalScrollbar.set(a,b)
            self.rightHorizontalScrollbar.set(a,b)
            self.leftText.xview("moveto",a)
            self.rightText.xview("moveto",a)
            self.mainFrame.update_idletasks()
            self.horizontalScrollbarUpdateInfo=10
        else:
            assert(0)

    def rightxset(self,a,b):
        self.leftxset(a,b)

    def leftyset(self,a,b):
        if self.verticalScrollbarUpdateInfo==40:
            self.verticalScrollbarUpdateInfo=0
            self.leftVerticalScrollbar.set(a,b)
            self.rightVerticalScrollbar.set(a,b)
        elif self.verticalScrollbarUpdateInfo==0:
            pass
        elif self.verticalScrollbarUpdateInfo==20:
            self.leftVerticalScrollbar.set(a,b)
            self.rightVerticalScrollbar.set(a,b)
        elif self.verticalScrollbarUpdateInfo==10:
            self.verticalScrollbarUpdateInfo=0
            self.leftVerticalScrollbar.set(a,b)
            self.rightVerticalScrollbar.set(a,b)
            self.leftText.yview("moveto",a)
            self.rightText.yview("moveto",a)
            self.mainFrame.update_idletasks()
            self.verticalScrollbarUpdateInfo=10
        else:
            assert(0)

    def rightyset(self,a,b):
        self.leftyset(a,b)

    def xview(self,*a):
        self.horizontalScrollbarUpdateInfo=20
        if len(a)==2:
            self.leftText.xview(a[0],a[1])
            self.rightText.xview(a[0],a[1])
        elif len(a)==3:
            self.leftText.xview(a[0],a[1],a[2])
            self.rightText.xview(a[0],a[1],a[2])
        else:
            assert(0)
        self.mainFrame.update_idletasks()
        self.horizontalScrollbarUpdateInfo=10

    def yview(self,*a):
        self.verticalScrollbarUpdateInfo=20
        if len(a)==2:
            self.leftText.yview(a[0],a[1])
            self.rightText.yview(a[0],a[1])
        elif len(a)==3:
            self.leftText.yview(a[0],a[1],a[2])
            self.rightText.yview(a[0],a[1],a[2])
        else:
            assert(0)
        self.mainFrame.update_idletasks()
        self.verticalScrollbarUpdateInfo=10

    def createStatusLine(self):
        self.statusFrame=tk.Frame(self.master)
        self.statusLabel = tk.Label(
                self.statusFrame,
                text="status",
                bd=1,
                relief=tk.SUNKEN,
                anchor=tk.W)
        self.statusLabel.pack(side=tk.LEFT,fill=tk.X,expand=1)
        self.linesLabel = tk.Label(
                self.statusFrame,
                text="lines",
                bd=1,
                relief=tk.SUNKEN,
                anchor=tk.W)
        self.linesLabel.pack(side=tk.RIGHT,fill=tk.X,expand=1)
        self.statusFrame.pack(side=tk.BOTTOM,fill=tk.X)

    def createMenubar(self):
        menuBar = tk.Menu()
        self.createFileMenu(menuBar)
        self.createViewMenu(menuBar)
        self.master.config(menu=menuBar)

    def createFileMenu(self, parentMenu):
        m = tk.Menu(parentMenu, tearoff=0)
        parentMenu.add_cascade(label="File", menu=m)
        m.add_command(label="Exit", command=self.onFileExit)

    def createViewMenu(self,parentMenu):
        m = tk.Menu(parentMenu, tearoff=0)
        parentMenu.add_cascade(label="View", menu=m)
        m.add_command(
                label="Find...",
                command=self.onViewFind,
                accelerator="Ctrl+F")
        m.add_command(
                label="Find Again",
                command=self.onViewFindAgain,
                accelerator="F3")

    def setStatus(self,s):
        self.statusLabel["text"]=s

    def createToolbar(self):
        self.buttonFrame=tk.Frame(self.master)

        l=tk.Label(self.buttonFrame,text="Changed",background="lightblue");
        l.pack(side=tk.RIGHT,padx=2,pady=2)
        l=tk.Label(self.buttonFrame,text="Deleted",background="lightgreen");
        l.pack(side=tk.RIGHT,padx=2,pady=2)
        l=tk.Label(self.buttonFrame,text="Added",background="pink");
        l.pack(side=tk.RIGHT,padx=2,pady=2)

        self.buttonFirstDiff=tk.Button(self.buttonFrame,text="<<",width=2,
                state=tk.DISABLED,
                command=self.navigateToFirstDiff)
        self.buttonFirstDiff.pack(side=tk.LEFT, padx=2, pady=2)
        self.buttonPreviousDiff=tk.Button(self.buttonFrame,text="<",
                state=tk.DISABLED,
                command=self.navigateToPreviousDiff)
        self.buttonPreviousDiff.pack(side=tk.LEFT, padx=2, pady=2)
        self.buttonNextDiff=tk.Button(self.buttonFrame,text=">",
                state=tk.DISABLED,
                command=self.navigateToNextDiff)
        self.buttonNextDiff.pack(side=tk.LEFT, padx=2, pady=2)
        self.buttonLastDiff=tk.Button(self.buttonFrame,text=">>",
                state=tk.DISABLED,
                command=self.navigateToLastDiff)
        self.buttonLastDiff.pack(side=tk.LEFT, padx=2, pady=2)

        self.buttonNextRedGreenDiff=tk.Button(self.buttonFrame,text="Next Red/Green",
                state=tk.NORMAL,
                command=self.navigateToNextRedGreenDiff)
        self.buttonNextRedGreenDiff.pack(side=tk.LEFT, padx=2, pady=2)

        self.buttonFrame.pack(side=tk.TOP,fill=tk.X)

    def navigateToFirstDiff(self):
        self.buttonFirstDiff.focus()
        if (self.navigationIndex is None) and (len(self.navigationList) != 0):
            self.navigationIndex=0
        if self.navigationIndex>0:
            self.navigationIndex=0
        self.navigateToIndex(-1)

    def navigateToPreviousDiff(self):
        self.buttonPreviousDiff.focus()
        if self.navigationIndex>0:
            self.navigationIndex=self.navigationIndex-1
        self.navigateToIndex(-1)

    def navigateToNextDiff(self):
        self.buttonNextDiff.focus()
        if (self.navigationIndex is None):
            self.navigationIndex=0
        else:
            if self.navigationIndex<len(self.navigationList)-1:
                self.navigationIndex=self.navigationIndex+1
        self.navigateToIndex(1)

    # navigate to the next green or red difference (insertions or removals)
    # but skip all blue differences (changes)
    def navigateToNextRedGreenDiff(self):
        self.buttonNextRedGreenDiff.focus()
        backupNavigationIndex=self.navigationIndex
        if (self.navigationIndex is None):
            self.navigationIndex=0
        else:
            self.navigationIndex=self.navigationIndex+1
        # find the next red/green navigation index
        while self.navigationIndex<len(self.navigationList):
            a,b,colorTag=self.navigationList[self.navigationIndex]
            #print a,b,colorTag, self.navigationIndex
            if colorTag == "red" or colorTag == "green":
                self.navigateToIndex(1)
                return
            self.navigationIndex=self.navigationIndex+1
        self.navigationIndex = backupNavigationIndex

    def navigateToLastDiff(self):
        self.buttonLastDiff.focus()
        if (self.navigationIndex is None) or (self.navigationIndex<len(self.navigationList)-1):
            self.navigationIndex=len(self.navigationList)-1
        self.navigateToIndex(1)

    def navigateToIndex(self,direction=1):
        if self.navigationIndex is None:
            self.buttonFirstDiff.config(state=tk.DISABLED)
            self.buttonPreviousDiff.config(state=tk.DISABLED)
            if len(self.navigationList)==0:
                self.buttonLastDiff.config(state=tk.DISABLED)
                self.buttonNextDiff.config(state=tk.DISABLED)
            else:
                self.buttonLastDiff.config(state=tk.NORMAL)
                self.buttonNextDiff.config(state=tk.NORMAL)
        else:
            a,b,colorTag=self.navigationList[self.navigationIndex]

            n=self.leftText.tag_names("%d.0" % a)
            n=list(filter(lambda x: x != "sel" and x != "highlight",n))
            if len(n)!=1:
                print(n)
                assert(len(n)==1)
            t="dark"+n[0]
            if t == "darkbluediffchar":
                t="darkblue"

            self.leftText.tag_config("highlight",background=t,foreground="white")
            self.rightText.tag_config("highlight",background=t,foreground="white")

            self.leftText.tag_remove("highlight",1.0,tk.END)
            self.rightText.tag_remove("highlight",1.0,tk.END)

            self.leftText.tag_add("highlight","%d.0" % a,"%d.0" % b)
            self.rightText.tag_add("highlight","%d.0" % a,"%d.0" % b)

            x = 0
            y = 0
            if t == "darkblue":
                leftString = self.leftData[a-1][0]
                rightString = self.rightData[a-1][0]
                xdleft,ydleft,xdright,ydright = self.onelinediff(leftString,rightString)
                x = xdleft
                y = ydleft

            if self.leftText.bbox("%d.%d" % (b,x)) is None or self.leftText.bbox("%d.%d" % (a,x)) is None:
                self.verticalScrollbarUpdateInfo=40
                self.horizontalScrollbarUpdateInfo=40
                if direction == 1:
                    self.leftText.see("%d.%d" % (min(b+10000,self.totalLines),x))
                    self.rightText.see("%d.%d" % (min(b+10000,self.totalLines),x))
                    self.leftText.see("%d.%d" % (a,x))
                    self.rightText.see("%d.%d" % (a,x))
                elif direction == -1:
                    self.leftText.see("%d.%d" % (max(a-10000,0),x))
                    self.rightText.see("%d.%d" % (max(a-10000,0),x))
                    self.leftText.see("%d.%d" % (b,x))
                    self.rightText.see("%d.%d" % (b,x))
                self.mainFrame.update_idletasks()
                self.verticalScrollbarUpdateInfo=10
                self.horizontalScrollbarUpdateInfo=10

            if self.navigationIndex==0:
                self.buttonFirstDiff.config(state=tk.DISABLED)
                self.buttonPreviousDiff.config(state=tk.DISABLED)
            else:
                self.buttonFirstDiff.config(state=tk.NORMAL)
                self.buttonPreviousDiff.config(state=tk.NORMAL)

            if self.navigationIndex>=len(self.navigationList)-1:
                self.buttonLastDiff.config(state=tk.DISABLED)
                self.buttonNextDiff.config(state=tk.DISABLED)
            else:
                self.buttonLastDiff.config(state=tk.NORMAL)
                self.buttonNextDiff.config(state=tk.NORMAL)

    def onFileExit(self):
        self.quit()

    def findAction(self):
        if self.findIgnoreCase:
            actualFindString=self.findString.upper()
        else:
            actualFindString=self.findString

        # Take current start position for find/search from
        #     - current selection
        #     - current insertion cursor
        #     - begin (or end for backward search) of file

        selectionRange = self.findTextWidget.tag_ranges(tk.SEL)
        if len(selectionRange) == 0:
            insertIndex = self.findTextWidget.index(tk.INSERT)
            if insertIndex != self.findTextWidget.index("%s-1c" % tk.END):
                # insert-index available
                newFindIndex = insertIndex
            else:
                # insert-index not available
                if self.findDirection == 1: # forward search
                    newFindIndex = "1.0"
                else:  # backward search
                    newFindIndex = self.findTextWidget.index(tk.END)
        else:
            if self.findDirection == 1:
                # forward search
                newFindIndex = selectionRange[0]
                newFindIndex = self.findTextWidget.index("%s+1c" % selectionRange[0])
            else:
                # backward search
                newFindIndex = selectionRange[1]
                newFindIndex = self.findTextWidget.index("%s-1c" % selectionRange[1])

        if self.findDirection == 1:
            # forward search
            findData = self.findTextWidget.get(newFindIndex,tk.END)
        else:
            # backward search
            findData = self.findTextWidget.get("1.0",newFindIndex)

        if self.findIgnoreCase:
            findData = findData.upper()

        if self.findDirection == 1:
            distance = findData.find(actualFindString)
        else:
            distance = findData.rfind(actualFindString)

        if distance >= 0:
            if self.findDirection == 1:
                newFindIndex = self.findTextWidget.index("%s+%dc" % (newFindIndex, distance))
            else:
                newFindIndex = self.findTextWidget.index("%s+%dc" % ("1.0", distance))
            beginSelectionIndex = newFindIndex
            endSelectionIndex = self.findTextWidget.index("%s+%sc" % (newFindIndex, len(actualFindString)))
            self.leftText.tag_remove(tk.SEL, 1.0, tk.END)
            self.rightText.tag_remove(tk.SEL, 1.0, tk.END)

            # The widget must have focus (on Windows platform),
            # otherwise tag SEL is ignored.
            self.findTextWidget.focus()
            self.findTextWidget.tag_add(tk.SEL,beginSelectionIndex,endSelectionIndex)
            self.findTextWidget.mark_set(tk.INSERT,endSelectionIndex)

            if (self.findTextWidget.bbox(beginSelectionIndex) is None or
                    self.findTextWidget.bbox(endSelectionIndex) is None):
                if self.findDirection == 1:
                    line,col=beginSelectionIndex.split(".")
                    self.findTextWidget.see("%d.%d" %
                            (min(int(line)+10000,self.totalLines),
                             int(col)))
                    self.findTextWidget.see(endSelectionIndex)
                    self.findTextWidget.see(beginSelectionIndex)
                elif self.findDirection == -1:
                    line,col=endSelectionIndex.split(".")
                    self.findTextWidget.see("%d.%d" %
                            (min(int(line)-10000,self.totalLines),
                             int(col)))
                    self.findTextWidget.see(beginSelectionIndex)
                    self.findTextWidget.see(endSelectionIndex)
        else:
            MessageDialog(self.master,
                    "Not found",
                    self.findString+" not found in "+self.findInWhatWindow+" window.")


    def onViewFind(self,event=None):
        dlg=FindDialog(self.master,defaultFindString=self.findString)
        if dlg.findString is not None:
            self.findString = dlg.findString
        # Do not modify self.findString if "Cancel" was pressed in FindDialog.
        if dlg.findString is not None and self.findString != "":
            self.findInWhatWindow=dlg.findInWhatWindow.get()
            self.findIgnoreCase=dlg.findIgnoreCase.get()
            if self.findInWhatWindow=="right":
                self.findData=rightData
                self.findTextWidget = self.rightText
            else:
                self.findData=self.leftData
                self.findTextWidget = self.leftText
            self.findDirection=dlg.findDirection.get()
            if self.findDirection == 1:   # find forward
                self.currentFindLine=0
            else:
                self.currentFindLine=self.totalLines-1
            self.findAction()

    def onViewFindAgain(self,dummyEvent=None):
        if self.findString is None or self.findString == "":
            self.onViewFind()
        else:
            self.currentFindLine=self.currentFindLine+self.findDirection
            self.findAction()

    def createPopupMenus(self):
        self.standardEditor = os.environ.get("EDITOR","").strip()
        self.leftPopupMenu = tk.Menu(tearoff=0)
        self.rightPopupMenu = tk.Menu(tearoff=0)
        if self.standardEditor != "":
            self.leftPopupMenu.add_command(
                    label="Edit ("+self.standardEditor+") left file",
                    command=self.editLeftFile)
            self.rightPopupMenu.add_command(
                    label="Edit ("+self.standardEditor+") right file",
                    command=self.editRightFile)
        if os.name == "nt":
            self.leftPopupMenu.add_command(label="Notepad",command=self.notepadLeftFile)
            self.rightPopupMenu.add_command(label="Notepad",command=self.notepadRightFile)
            self.leftPopupMenu.add_command(label="Wordpad",command=self.wordpadLeftFile)
            self.rightPopupMenu.add_command(label="Wordpad",command=self.wordpadRightFile)
        else:
            self.leftPopupMenu.add_command(label="nedit", command=self.neditLeftFile)
            self.leftPopupMenu.add_command(label="xemacs", command=self.xemacsLeftFile)
            self.leftPopupMenu.add_command(label="vi", command=self.viLeftFile)
            self.rightPopupMenu.add_command(label="nedit", command=self.neditRightFile)
            self.rightPopupMenu.add_command(label="xemacs", command=self.xemacsRightFile)
            self.rightPopupMenu.add_command(label="vi", command=self.viRightFile)

    def popupLeftMenu(self,ev):
        self.unpostContextMenus()
        self.leftPopupMenu.post(ev.x_root,ev.y_root)

    def popupRightMenu(self,ev):
        self.unpostContextMenus()
        self.rightPopupMenu.post(ev.x_root,ev.y_root)

    def unpostContextMenus(self,ev=None):
        self.leftPopupMenu.unpost()
        self.rightPopupMenu.unpost()

    def startEditor(self,editor,file):
        cmd = editor + " " + file + " &"
        rc = os.system(cmd)
        if rc is not None and rc != 0:
            print("\""+cmd+"\" returned "+str(rc))

    def neditLeftFile(self):
        self.startEditor("nedit", self.filename1)

    def xemacsLeftFile(self):
        self.startEditor("xemacs", self.filename1)

    def viLeftFile(self):
        self.startEditor("xterm -e vi", self.filename1)

    def editLeftFile(self):
        self.startEditor("xterm -e "+self.standardEditor, self.filename1)

    def neditRightFile(self):
        self.startEditor("nedit", self.filename2)

    def xemacsRightFile(self):
        self.startEditor("xemacs", self.filename2)

    def viRightFile(self):
        self.startEditor("xterm -e vi", self.filename2)

    def editRightFile(self):
        self.startEditor("xterm -e "+self.standardEditor, self.filename2)

    def notepadLeftFile(self):
        self.startEditor("notepad", self.filename1)

    def notepadRightFile(self):
        self.startEditor("notepad", self.filename2)

    def wordpadLeftFile(self):
        self.startEditor("write", self.filename1)

    def wordpadRightFile(self):
        self.startEditor("write", self.filename2)

    def filterKey(self, event):
        # Filter all keys which might modify the text.

        #print "sym=<"+ev.keysym+">, code=<"+str(ev.keycode)+">, chr=<"+ev.char+">, state= <"+str(ev.state)+">"

        controlKeyDown = event.state & 4

        if event.keysym in ["Left", "Right", "Up", "Down",
                "Prior", "Next", "Home", "End",
                "Escape", "F3"]:
            return

        if controlKeyDown and event.keysym in [ "f", "c", "x" ]:
            return

        # The event is considered representing a key,
        # which would modify the text, which is not desired.
        return "break"
    
    def viewFiles(self, filename1, filename2):
        self.filename1 = filename1
        self.filename2 = filename2

        self.diffRecords=[]

        try:
            self.leftLabel.insert(tk.END, self.filename1)
            self.filename1 = self.filename1

            self.leftData=[]
            leftStream=open(self.filename1)
            line=leftStream.readline()
            while line != "":
                self.leftData.append([line,None])
                line=leftStream.readline()
            leftStream.close()

            self.rightLabel.insert(tk.END, self.filename2)

            self.rightData=[]
            self.rightData = self.rightData
            rightStream=open(self.filename2)
            line=rightStream.readline()
            while line != "":
                self.rightData.append([line,None])
                line=rightStream.readline()
            rightStream.close()

            diffCommand = "/usr/bin/diff"

            if self.ignoreBlankFlagString != "":
                diffCommand = diffCommand + " " + self.ignoreBlankFlagString

            diffCommand = diffCommand + " " + self.filename1 + " " + self.filename2

            with os.popen(diffCommand) as stream:
                for line in stream:
                    line=line.rstrip()
                    if (len(line)>=1 and
                        line[0] != ">" and
                        line[0] != "<" and
                        line != "---"):
                        for x in ["a","c","d"]:
                            fields = line.split(x)
                            assert(len(fields)==1 or len(fields)==2)
                            if len(fields)==2:
                                leftfields=fields[0].split(",")
                                assert(len(leftfields)<=2)
                                a1=int(leftfields[0])
                                if len(leftfields)==1:
                                    a2=a1
                                else:
                                    a2=int(leftfields[1])
                                rightfields=fields[1].split(",")
                                assert(len(rightfields)<=2)
                                b1=int(rightfields[0])
                                if len(rightfields)==1:
                                    b2=b1
                                else:
                                    b2=int(rightfields[1])
                                self.diffRecords.append((x,a1,a2,b1,b2))

            # print "diffRecords:", self.diffRecords

            if len(self.diffRecords)==0:
                msg="No differences found."
                print(msg)
                self.setStatus(msg)
            elif len(self.diffRecords)==1:
                msg=str(len(self.diffRecords))+" difference found."
                print(msg)
                self.setStatus(msg)
            else:
                msg=str(len(self.diffRecords))+" differences found."
                print(msg)
                self.setStatus(msg)

            self.diffRecords.reverse()

            # First traversal does not modify the diffRecords.
            for t,a1,a2,b1,b2 in self.diffRecords:
                if t=="a":
                    # Something that only exists on the right side.
                    assert(a1==a2)
                    assert(b1<=b2)
                    i=b1
                    while i<=b2:
                        self.rightData[i-1][1]="red"
                        i=i+1

                if t=="d":
                    # Something that only exists on the left side.
                    assert(b1==b2)
                    assert(a1<=a2)
                    i=a1
                    while i<=a2:
                        self.leftData[i-1][1]="green"
                        i=i+1

                if t=="c":
                    # Something that exists on both sides.
                    assert(a1<=a2)
                    assert(b1<=b2)
                    i=a1
                    while i<=a2:
                        self.leftData[i-1][1]="blue"
                        i=i+1
                    i=b1
                    while i<=b2:
                        self.rightData[i-1][1]="blue"
                        i=i+1

            # Second traversal adds the added and deleted fragments.
            for t,a1,a2,b1,b2 in self.diffRecords:
                if t=="a":
                        # Something that only exists on the right side.
                        assert(a1==a2)
                        assert(b1<=b2)
                        i=b1
                        while i<=b2:
                            self.leftData.insert(a1,["\n","red"])
                            i=i+1
                if t=="d":
                        # Something that only exists on the left side.
                        assert(b1==b2)
                        assert(a1<=a2)
                        i=a1
                        while i<=a2:
                            self.rightData.insert(b1,["\n","green"])
                            i=i+1
                if t=="c":
                        # Something that changed between the two sides.
                        assert(a1<=a2)
                        assert(b1<=b2)
                        if a2-a1 < b2-b1:
                            i=b1+a2-a1
                            while i<b2:
                                self.leftData.insert(a2,["\n","blue"])
                                i=i+1
                        elif a2-a1 > b2-b1:
                            i=a1+b2-b1
                            while i<a2:
                                self.rightData.insert(b2,["\n","blue"])
                                i=i+1

            self.diffRecords.reverse()   # For canvasChanged in ascending order.

            lineNumber=1
            oldTag=None
            a=None
            b=None
            for x,t in self.leftData+[("Dummy", None)]:
                if t != oldTag:
                    if a is not None:
                        b=lineNumber
                        self.navigationList.append((a,b,oldTag))
                    if t is None:
                        a=None
                    else:
                        a=lineNumber
                oldTag=t
                lineNumber=lineNumber+1

            self.totalLines=lineNumber-2

            self.linesLabel.config(text="Total lines: %d" % self.totalLines)

            self.leftText.tag_config("red", background="pink")
            self.leftText.tag_config("green", background="lightgreen")
            self.leftText.tag_config("blue", background="lightblue")
            self.leftText.tag_config("highlight", background="black", foreground="white")
            # diffchar tag must be created after highlight tag in order to have priority
            # (still be visible when highlighted)
            self.leftText.tag_config("bluediffchar",
                    background="red",
                    foreground="white",
                    relief=tk.GROOVE)
            self.leftText.tag_raise(tk.SEL)  # SEL overrides all other tags
            self.leftText.tag_config(tk.SEL, background="black", foreground="white")

            self.rightText.tag_config("red", background="pink")
            self.rightText.tag_config("green", background="lightgreen")
            self.rightText.tag_config("blue", background="lightblue")
            self.rightText.tag_config("highlight", background="black", foreground="white")
            # diffchar tag must be created after highlight tag in order to have priority
            self.rightText.tag_config("bluediffchar",
                    background="red",
                    foreground="white",
                    relief=tk.GROOVE)
            self.rightText.tag_raise(tk.SEL)  # SEL overrides all other tags
            self.rightText.tag_config(tk.SEL, background="black", foreground="white")

            assert(len(self.leftData)==self.totalLines)
            assert(len(self.rightData)==self.totalLines)

            lineNumber=0
            while lineNumber<self.totalLines:
                leftLine,leftTag=self.leftData[lineNumber]
                rightLine,rightTag=self.rightData[lineNumber]
                assert(leftTag==rightTag)
                if (leftTag == "blue" and
                    leftLine != "" and leftLine != "\n" and
                    rightLine != "" and rightLine != "\n"):
                    xdleft,ydleft,xdright,ydright = self.onelinediff(leftLine,rightLine)
                    # xdleft points now to the first different character of the line
                    # ydleft points to first different character from the end

                    self.leftText.insert(tk.END, leftLine[:xdleft], "blue")
                    self.leftText.insert(tk.END, leftLine[xdleft:len(leftLine)-ydleft], "bluediffchar")
                    self.leftText.insert(tk.END, leftLine[len(leftLine)-ydleft:], "blue")
                    self.rightText.insert(tk.END, rightLine[:xdright], "blue")
                    self.rightText.insert(tk.END, rightLine[xdright:len(rightLine)-ydright], "bluediffchar")
                    self.rightText.insert(tk.END, rightLine[len(rightLine)-ydright:], "blue")
                else:
                    self.leftText.insert(tk.END, leftLine, leftTag)
                    self.rightText.insert(tk.END, rightLine, rightTag)
                lineNumber=lineNumber+1

            self.navigateToIndex()
        except IOError as exception:
            exstr = str(exception)
            sys.stderr.write(exstr+"\n")
            MessageDialog(self, "xdiff IO Error", exstr)
            sys.exit(1)

    def prepareLineForDiff(self, line):
        lineData = []
        for i in range(len(line)):
            ch = line[i]
            if self.ignoreBlankFlagString == "-w":
                if ch not in [ " ", "\t", "\r", "\n" ]:
                    lineData.append((ch, i))
            else:
                lineData.append((ch, i))
        return lineData

    def onelinediff(self, leftLine, rightLine):
        if leftLine == rightLine:
            return(0, 0, 0, 0)

        leftLineData = self.prepareLineForDiff(leftLine)
        rightLineData = self.prepareLineForDiff(rightLine)
        x = 0
        y1 = len(leftLineData)-1
        y2 = len(rightLineData)-1
        xmax = min(y1, y2)
        while x <= xmax:
            if leftLineData[x][0] != rightLineData[x][0]:
                break
            x += 1
        # x points now to the first different character of the line

        y=0
        while y1 - y > x and y2 - y > x:
            if leftLineData[y1-y][0] != rightLineData[y2-y][0]:
                break
            y += 1
        # y points to first different character from the end
        #print x,y,leftLineData[y][1],y1

        xdleft = leftLineData[x][1]
        xdright = rightLineData[x][1]
        ydleft = len(leftLine)-leftLineData[y1-y][1]-1
        ydright = len(rightLine)-rightLineData[y2-y][1]-1

        result = (xdleft,ydleft,xdright,ydright)
        #print "result=",result
        return result


class DiffTool:
    def __init__(self):
        self.filename1 = None
        self.filename2 = None
        self.ignoreBlankFlagString = ""

    def usage(self, *arguments):
        warn(*arguments)
        warn("xdiff: diff two files")
        warn("Usage: xdiff [ options ] file1 file2")
        warn("    -w    ignore all blanks")
        warn("    -b    ignore trailing blanks")
        sys.exit(2)

    def processCommandLine(self):
        try:
            self.processArguments(sys.argv[1:])
        except KeyboardInterrupt:
            print('Interrupted ...')
            # 130 is the standard Unix exit code for a program
            # terminated by SIGINT (Ctrl-C): 128 + signal number 2.
            sys.exit(130)

    def processArguments(self, arguments):
        try:
            options, arguments = getopt.getopt(arguments, 'bw')
        except getopt.GetoptError as exception:
            error(exception)

        for key, value in options:
            if key == '-w':
                self.ignoreBlankFlagString = "-w"
            elif key == '-b':
                self.ignoreBlankFlagString = "-b"
            else:
                error('unexpected command line option', key)
        if len(arguments) < 2:
            self.usage("Two file names expected.")
        elif len(arguments) > 2:
            self.usage("Too many parameters.")
        else:
            self.filename1, self.filename2 = arguments
            self.processFiles()

    def processFiles(self):
        if not os.path.exists(self.filename1):
            error(self.filename1, 'not found.')
        if not os.path.exists(self.filename2):
            error(self.filename2, 'not found.')
        if os.path.isdir(self.filename1):
            if os.path.isdir(self.filename2):
                self.processDirectories()
            elif os.path.isfile(self.filename2):
                self.filename1 = os.path.join(self.filename1, os.path.basename(self.filename2))
                self.processRegularFiles()
            else:
                error(self.filename2, 'is not a regular file or a directory.')
        elif os.path.isfile(self.filename1):
            if os.path.isdir(self.filename2):
                self.filename2 = os.path.join(self.filename2, os.path.basename(self.filename1))
                self.processRegularFiles()
            elif os.path.isfile(self.filename2):
                self.processRegularFiles()
            else:
                error(self.filename2, 'is not a regular file or a directory.')
        else:
            error(self.filename1, 'is not a regular file or a directory.')

    def processDirectories(self):
        if self.areFilesIdentical():
            warn('The directories are identical.')
            return 
        error('comparing directories not yet supported')

    def processRegularFiles(self):
        if self.areFilesIdentical():
            warn('The files are identical.')
            return 
        try:
            self.root = tk.Tk()
        except tk.TclError as exception:
            print(exception)
            sys.exit(2)

        self.root.title("xdiff")

        self.viewer = DiffViewer(self.root)
        self.viewer.ignoreBlankFlagString = self.ignoreBlankFlagString
        self.viewer.viewFiles(self.filename1, self.filename2)
        self.root.mainloop()

    def areFilesIdentical(self):
        stat1 = os.stat(self.filename1)
        stat2 = os.stat(self.filename2)
        return stat1.st_dev == stat2.st_dev and stat1.st_ino == stat2.st_ino

if __name__ == "__main__":
    DiffTool().processCommandLine()


