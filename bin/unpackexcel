#!/usr/bin/python3

# unpackexcel
#
# Unpack an xlsx Excel file for the purpose of analyzing it.
#

import sys, zipfile, os.path, shutil, re

TAG_RE = re.compile(r'(?s)<\?[^?]*\?>|<!--.*?-->|<!\[CDATA\[.*?\]\]>|</?[^>]+>')

class ExcelUnpacker:
    def warning(self, *messages):
        print(*messages)

    def error(self, *messages):
        self.warning(*messages)
        sys.exit(2)

    def processCommandLine(self, argv):
        self.processArguments(argv[1:])
 
    def processArguments(self, arguments):
        for filename in arguments:
            if not filename.endswith('.xlsx'):
                filename = filename + '.xlsx'
            self.currentFilename = filename
            self.processCurrentFilename()

    def processCurrentFilename(self):
        print('Process', self.currentFilename)
        self.unzipCurrentFilename()
        self.formatFiles()

    def unzipCurrentFilename(self):
        self.currentRootName, ext = os.path.splitext(self.currentFilename)
        if ext != '.xlsx':
            self.error('Only xlsx files are supported')
        if os.path.exists(self.currentRootName):
            shutil.rmtree(self.currentRootName)
        with zipfile.ZipFile(self.currentFilename, 'r') as zip:
            zip.extractall(self.currentRootName)

    def formatFiles(self):
        for root, dirs, files in os.walk(self.currentRootName):
            for file in files:
                file = os.path.join(root, file)
                self.formatFile(file)

    def formatFile(self, file):
        print('    Format', file)
        with open(file) as stream:
            xml = stream.read()
        stream = open(file+'_formatted', 'w')
        newXml = self.format_xml(xml)
        stream.write(newXml)
        stream.close()
        os.rename(file+'_formatted', file)

    def format_xml(self, text, indent = '  '):
        parts = []
        pos = 0
        level = 0

        def emit(s):
            if s.strip():
                parts.append(indent * level + s.strip())

        for m in TAG_RE.finditer(text):
            if m.start() > pos:
                emit(text[pos:m.start()])
            token = m.group(0)
            if token.startswith('<?'):
                emit(token)    # preserve case
            elif token.startswith('<!--') or token.startswith('<![CDATA['):
                emit(token)
            elif token.startswith('</'):
                level = max(level-1, 0)
                emit(token)
            else:
                is_self = token.endswith('/>')
                emit(token)
                if not is_self:
                    level += 1
            pos = m.end()
    
        if pos < len(text):
            emit(text[pos:])

        return '\n'.join(parts) + '\n'

if __name__ == '__main__':
    ExcelUnpacker().processCommandLine(sys.argv)
 
