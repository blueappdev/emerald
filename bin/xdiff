#!/usr/bin/python3
#
# xdiff
#

import os, sys, filecmp, string, getopt, time, difflib, re
import tkinter as tk
import tkinter.simpledialog

def warn(*arguments):
    print(*arguments, file=sys.stderr)

def error(*arguments):
    warn(*arguments)
    sys.exit(2)

class MessageDialog(tk.simpledialog.Dialog):
    def  __init__(self, parent, title = "title", text="message"):
        self.titleString = title
        self.messageString = text
        tk.simpledialog.Dialog.__init__(self,parent)

    def buttonbox(self):
        box = tk.Frame(self)
        self.button = tk.Button(box,
                text = "OK", width = 10,
                command = self.ok, default = tk.ACTIVE)
        self.button.pack(side = tk.LEFT, padx = 5, pady = 5)
        self.bind("<Return>", self.ok)
        self.bind("<Escape>", self.ok)
        box.pack()

    def body(self, master):
        self.title(self.titleString)
        #self.messageLabel = tk.Label(master, width = 16, text = self.messageString)
        self.messageLabel = tk.Label(master, text = self.messageString)
        #self.messageLabel.grid(row = 0, column = 1, stick = tk.W)
        self.messageLabel.grid()
        return None # self.button # for focus_set

class FindDialog(tk.simpledialog.Dialog):
    def __init__(self,parent,defaultFindString = ""):
        self.defaultFindString = defaultFindString
        tk.simpledialog.Dialog.__init__(self, parent)

    def body(self, master):
        self.title("Find")
        self.findString = None
        self.findStringVar = tk.StringVar()
        if self.defaultFindString is None:
            self.findStringVar.set("")
        else:
            self.findStringVar.set(self.defaultFindString)
        tk.Label(master,text="Find:").grid(
            row=0, column=0,
            stick=tk.W)
        self.entry = tk.Entry(master,textvariable = self.findStringVar,
            background = "white")
        self.entry.grid(row=0, column=1,
            columnspan=4, stick=tk.EW)
        self.entry.selection_range(0,tk.END)
        self.entry.icursor(tk.END)
        self.findInWhatWindow = tk.StringVar()
        self.findInWhatWindow.set("left")
        self.findDirection = tk.IntVar()
        self.findDirection.set(1)
        self.findIgnoreCase = tk.IntVar()
        self.findIgnoreCase.set(1)
        rb = tk.Radiobutton(master,
                text = "Forward",
                variable = self.findDirection,
                value = 1)
        rb.grid(row = 1, column = 1, stick = tk.W)
        rb = tk.Radiobutton(master,
                text = "Backward",
                variable = self.findDirection,
                value = -1)
        rb.grid(row = 2, column = 1, stick = tk.W)
        rb = tk.Checkbutton(master,
                text = "Ignore Case",
                variable = self.findIgnoreCase)
        rb.grid(row = 1,column = 2, stick = tk.W)
        rb = tk.Radiobutton(master,
                text = "Left Window",
                variable = self.findInWhatWindow,
                value = "left")
        rb.grid(row = 1, column = 3, stick = tk.W)
        rb=tk.Radiobutton(master,
                text="Right Window",
                variable=self.findInWhatWindow,
                value="right")
        rb.grid(row=2,column=3,stick=tk.W)
        return self.entry #for focus_set

    def apply(self):
        self.findString=self.entry.get()


class DiffViewer(tk.Frame):
    def __init__(self, master):
        self.quietMode=False
        self.createPopupMenus()
        self.horizontalScrollbarUpdateInfo=10
        self.verticalScrollbarUpdateInfo=10
        self.findString=None
        self.navigationList=[]
        self.navigationIndex=None
        tk.Frame.__init__(self, master=master)
        self.master.protocol("WM_DELETE_WINDOW", self.onFileExit)

        # Send explicitly the unpost context menu,
        # whenever the mouse button is pressed
        # (The context menu does not disappear on Unix,
        # when clicked outside the context menu.)
        self.master.bind("<Button-1>", self.unpostContextMenus)

        self.pack()
        self.createMenubar()
        self.createToolbar()
        self.createStatusLine()

        self.mainFrame=tk.Frame(self.master, width=1500, height=1100)
        self.master.bind("<Control-f>", self.onViewFind)
        self.master.bind("<F3>", self.onViewFindAgain)

        #
        # Left Frame
        #
        self.leftFrame = tk.Frame(self.mainFrame)
        self.leftLabel = tk.Entry(self.leftFrame, bd=1, relief=tk.SUNKEN)
        self.leftLabel.pack(side=tk.TOP,fill=tk.X)
        self.leftVerticalScrollbar=tk.Scrollbar(self.leftFrame,
                orient = tk.VERTICAL)
        self.leftHorizontalScrollbar=tk.Scrollbar(self.leftFrame,
                orient = tk.HORIZONTAL)
        self.leftText = tk.Text(self.leftFrame,
                bg="white",
                xscrollcommand=self.leftxset,
                yscrollcommand=self.leftyset)
        if os.name == "nt":
            self.leftText.config(font=("Courier",8))
        self.leftText.config(wrap=tk.NONE)
        self.leftVerticalScrollbar.pack(side=tk.RIGHT,fill=tk.Y)
        self.leftHorizontalScrollbar.pack(side=tk.BOTTOM,fill=tk.X)
        self.leftText.pack(fill=tk.BOTH,expand=1)
        #self.leftFrame.pack(side=tk.LEFT,fill=tk.BOTH,expand=1)
        #self.leftFrame.grid(row=0,column=0,stick=tk.NSEW,expand=1)
        self.leftFrame.place(relwidth=0.5,width=-7,relheight=1)

        self.leftText.bind("<Key>", self.filterKey)
        self.leftText.bind("<Button-3>", self.popupLeftMenu)
        self.leftLabel.bind("<Key>", self.filterKey)
        self.leftLabel.bind("<Button-3>", self.popupLeftMenu)

        #
        # Right Frame
        #
        self.rightFrame = tk.Frame(self.mainFrame)
        self.rightLabel = tk.Entry(self.rightFrame, bd = 1, relief = tk.SUNKEN)
        self.rightLabel.pack(side = tk.TOP, fill = tk.X)
        self.rightVerticalScrollbar = tk.Scrollbar(self.rightFrame,
                orient = tk.VERTICAL)
        self.rightHorizontalScrollbar = tk.Scrollbar(self.rightFrame,
                orient = tk.HORIZONTAL)
        self.rightText = tk.Text(self.rightFrame,
                bg="white",
                xscrollcommand = self.rightxset,
                yscrollcommand = self.rightyset)
        if os.name == "nt":
            self.rightText.config(font=("Courier",8))
        self.rightText.config(wrap=tk.NONE)
        self.rightVerticalScrollbar.pack(side=tk.RIGHT,fill=tk.Y)
        self.rightHorizontalScrollbar.pack(side=tk.BOTTOM,fill=tk.X)
        self.rightText.pack(fill=tk.BOTH,expand=1)
        #self.rightFrame.pack(side=tk.LEFT,fill=tk.BOTH,expand=1)
        #self.rightFrame.grid(row=0,column=1,stick=tk.NSEW,expand=1)
        self.rightFrame.place(relx=0.5,x=-7,width=-7,relwidth=0.5,relheight=1)

        self.rightText.bind("<Key>", self.filterKey)
        self.rightText.bind("<Button-3>", self.popupRightMenu)
        self.rightLabel.bind("<Key>", self.filterKey)
        self.rightLabel.bind("<Button-3>", self.popupRightMenu)

        # Connect scrollbars with widgets.
        self.leftVerticalScrollbar.config(command=self.yview)
        self.leftHorizontalScrollbar.config(command=self.xview)
        self.rightVerticalScrollbar.config(command=self.yview)
        self.rightHorizontalScrollbar.config(command=self.xview)

        self.canvas=tk.Canvas(self.mainFrame,background="white")
        self.canvas.place(relx=1,x=-14,width=14,relheight=1,height=-52,y=35)
        self.canvas.place(relx=1,x=-14,width=14,relheight=1,height=-52,y=35)
        self.canvas.bind("<Configure>", self.canvasChanged)

        #
        self.mainFrame.pack(fill=tk.BOTH,expand=1)

    def print(self, *arguments):
        print(arguments)

    def quietPrint(self, *arguments):
        if self.quietMode:
            return
        self.print(arguments)

    def canvasChanged(self,event):
        # canvas size changed, re-paint all rectangles
        self.canvas.delete(tk.ALL)
        a = 0  # cumulation of lines
        b = 0
        leftdelta=0
        rightdelta=0
        for t,lefta,leftb,righta,rightb in self.diffRecords:
            assert self.leftText.index(tk.END) == self.rightText.index(tk.END)
            x,y=map(int, self.leftText.index(tk.END).split("."))
            a=max(lefta+leftdelta,righta+rightdelta)
            b=a+max(leftb-lefta,rightb-righta)+1
            #print t,lefta,"(",lefta+leftdelta,")",leftb,righta,"(",righta+rightdelta,")",rightb,a,b
            if t=="a":
                self.canvas.create_rectangle(
                        0,
                        (a-1)*event.height/x,14,
                        (b-1)*event.height/x,
                        fill="green",
                        outline="green")
                leftdelta=leftdelta + rightb - righta + 1
            if t=="d":
                self.canvas.create_rectangle(
                        0,(a-1)*event.height/x,
                        14,
                        (b-1)*event.height/x,
                        fill="red",
                        outline="red")
                rightdelta=rightdelta + leftb - lefta + 1
            if t=="c":
                self.canvas.create_rectangle(0,
                        (a-1)*event.height/x,
                        14,
                        (b-1)*event.height/x,
                        fill="blue",
                        outline="blue")
                d=(leftb - lefta) - (rightb - righta)
                if d < 0:
                    leftdelta=leftdelta + abs(d) + 1
                if d > 0:
                    rightdelta=rightdelta + abs(d) + 1

    def leftxset(self,a,b):
        if self.horizontalScrollbarUpdateInfo==40:
            self.horizontalScrollbarUpdateInfo=0
            self.leftHorizontalScrollbar.set(a,b)
            self.rightHorizontalScrollbar.set(a,b)
        elif self.horizontalScrollbarUpdateInfo==0:
            pass
        elif self.horizontalScrollbarUpdateInfo==20:
            self.leftHorizontalScrollbar.set(a,b)
            self.rightHorizontalScrollbar.set(a,b)
        elif self.horizontalScrollbarUpdateInfo==10:
            self.horizontalScrollbarUpdateInfo=0
            self.leftHorizontalScrollbar.set(a,b)
            self.rightHorizontalScrollbar.set(a,b)
            self.leftText.xview("moveto",a)
            self.rightText.xview("moveto",a)
            self.mainFrame.update_idletasks()
            self.horizontalScrollbarUpdateInfo=10
        else:
            raise Exception('leftxset')

    def rightxset(self,a,b):
        self.leftxset(a,b)

    def leftyset(self,a,b):
        if self.verticalScrollbarUpdateInfo==40:
            self.verticalScrollbarUpdateInfo=0
            self.leftVerticalScrollbar.set(a,b)
            self.rightVerticalScrollbar.set(a,b)
        elif self.verticalScrollbarUpdateInfo==0:
            pass
        elif self.verticalScrollbarUpdateInfo==20:
            self.leftVerticalScrollbar.set(a,b)
            self.rightVerticalScrollbar.set(a,b)
        elif self.verticalScrollbarUpdateInfo==10:
            self.verticalScrollbarUpdateInfo=0
            self.leftVerticalScrollbar.set(a,b)
            self.rightVerticalScrollbar.set(a,b)
            self.leftText.yview("moveto",a)
            self.rightText.yview("moveto",a)
            self.mainFrame.update_idletasks()
            self.verticalScrollbarUpdateInfo=10
        else:
            raise Exception('leftyset')

    def rightyset(self, a, b):
        self.leftyset(a, b)

    def xview(self, *a):
        self.horizontalScrollbarUpdateInfo=20
        if len(a)==2:
            self.leftText.xview(a[0],a[1])
            self.rightText.xview(a[0],a[1])
        elif len(a)==3:
            self.leftText.xview(a[0],a[1],a[2])
            self.rightText.xview(a[0],a[1],a[2])
        else:
            raise Exception('xview')
        self.mainFrame.update_idletasks()
        self.horizontalScrollbarUpdateInfo=10

    def yview(self, *a):
        self.verticalScrollbarUpdateInfo=20
        if len(a)==2:
            self.leftText.yview(a[0],a[1])
            self.rightText.yview(a[0],a[1])
        elif len(a)==3:
            self.leftText.yview(a[0],a[1],a[2])
            self.rightText.yview(a[0],a[1],a[2])
        else:
            raise Exception('yview')
        self.mainFrame.update_idletasks()
        self.verticalScrollbarUpdateInfo=10

    def createStatusLine(self):
        self.statusFrame=tk.Frame(self.master)
        self.statusLabel = tk.Label(
                self.statusFrame,
                text="status",
                bd=1,
                relief=tk.SUNKEN,
                anchor=tk.W)
        self.statusLabel.pack(side=tk.LEFT,fill=tk.X,expand=1)
        self.linesLabel = tk.Label(
                self.statusFrame,
                text="lines",
                bd=1,
                relief=tk.SUNKEN,
                anchor=tk.W)
        self.linesLabel.pack(side=tk.RIGHT,fill=tk.X,expand=1)
        self.statusFrame.pack(side=tk.BOTTOM,fill=tk.X)

    def createMenubar(self):
        newMenuBar = tk.Menu()
        self.createFileMenu(newMenuBar)
        self.createViewMenu(newMenuBar)
        self.master.config(menu=newMenuBar)

    def createFileMenu(self, parentMenu):
        newMenu = tk.Menu(parentMenu, tearoff=0)
        parentMenu.add_cascade(label="File", menu=newMenu)
        newMenu.add_command(label="Exit", command=self.onFileExit)

    def createViewMenu(self, parentMenu):
        newMenu = tk.Menu(parentMenu, tearoff=0)
        parentMenu.add_cascade(label="View", menu=newMenu)
        newMenu.add_command(
                label="Find...",
                command=self.onViewFind,
                accelerator="Ctrl+F")
        newMenu.add_command(
                label="Find Again",
                command=self.onViewFindAgain,
                accelerator="F3")

    def setStatus(self, message):
        self.statusLabel["text"] = message

    def createToolbar(self):
        self.buttonFrame=tk.Frame(self.master)

        l=tk.Label(self.buttonFrame,text="Changed",background="lightblue");
        l.pack(side=tk.RIGHT,padx=2,pady=2)
        l=tk.Label(self.buttonFrame,text="Deleted",background="lightgreen");
        l.pack(side=tk.RIGHT,padx=2,pady=2)
        l=tk.Label(self.buttonFrame,text="Added",background="pink");
        l.pack(side=tk.RIGHT,padx=2,pady=2)

        self.buttonFirstDiff=tk.Button(self.buttonFrame,text="<<",width=2,
                state=tk.DISABLED,
                command=self.navigateToFirstDiff)
        self.buttonFirstDiff.pack(side=tk.LEFT, padx=2, pady=2)
        self.buttonPreviousDiff=tk.Button(self.buttonFrame,text="<",
                state=tk.DISABLED,
                command=self.navigateToPreviousDiff)
        self.buttonPreviousDiff.pack(side=tk.LEFT, padx=2, pady=2)
        self.buttonNextDiff=tk.Button(self.buttonFrame,text=">",
                state=tk.DISABLED,
                command=self.navigateToNextDiff)
        self.buttonNextDiff.pack(side=tk.LEFT, padx=2, pady=2)
        self.buttonLastDiff=tk.Button(self.buttonFrame,text=">>",
                state=tk.DISABLED,
                command=self.navigateToLastDiff)
        self.buttonLastDiff.pack(side=tk.LEFT, padx=2, pady=2)

        self.buttonNextRedGreenDiff=tk.Button(self.buttonFrame,text="Next Red/Green",
                state=tk.NORMAL,
                command=self.navigateToNextRedGreenDiff)
        self.buttonNextRedGreenDiff.pack(side=tk.LEFT, padx=2, pady=2)

        self.buttonFrame.pack(side=tk.TOP,fill=tk.X)

    def navigateToFirstDiff(self):
        self.buttonFirstDiff.focus()
        if (self.navigationIndex is None) and (len(self.navigationList) != 0):
            self.navigationIndex=0
        if self.navigationIndex>0:
            self.navigationIndex=0
        self.navigateToIndex(-1)

    def navigateToPreviousDiff(self):
        self.buttonPreviousDiff.focus()
        if self.navigationIndex>0:
            self.navigationIndex=self.navigationIndex-1
        self.navigateToIndex(-1)

    def navigateToNextDiff(self):
        self.buttonNextDiff.focus()
        if (self.navigationIndex is None):
            self.navigationIndex=0
        else:
            if self.navigationIndex<len(self.navigationList)-1:
                self.navigationIndex=self.navigationIndex+1
        self.navigateToIndex(1)

    # navigate to the next green or red difference (insertions or removals)
    # but skip all blue differences (changes)
    def navigateToNextRedGreenDiff(self):
        self.buttonNextRedGreenDiff.focus()
        backupNavigationIndex=self.navigationIndex
        if (self.navigationIndex is None):
            self.navigationIndex=0
        else:
            self.navigationIndex=self.navigationIndex+1
        # find the next red/green navigation index
        while self.navigationIndex<len(self.navigationList):
            a,b,colorTag=self.navigationList[self.navigationIndex]
            #print a,b,colorTag, self.navigationIndex
            if colorTag == "red" or colorTag == "green":
                self.navigateToIndex(1)
                return
            self.navigationIndex=self.navigationIndex+1
        self.navigationIndex = backupNavigationIndex

    def navigateToLastDiff(self):
        self.buttonLastDiff.focus()
        if (self.navigationIndex is None) or (self.navigationIndex<len(self.navigationList)-1):
            self.navigationIndex=len(self.navigationList)-1
        self.navigateToIndex(1)

    def navigateToIndex(self,direction=1):
        if self.navigationIndex is None:
            self.buttonFirstDiff.config(state=tk.DISABLED)
            self.buttonPreviousDiff.config(state=tk.DISABLED)
            if len(self.navigationList)==0:
                self.buttonLastDiff.config(state=tk.DISABLED)
                self.buttonNextDiff.config(state=tk.DISABLED)
            else:
                self.buttonLastDiff.config(state=tk.NORMAL)
                self.buttonNextDiff.config(state=tk.NORMAL)
        else:
            a,b,colorTag=self.navigationList[self.navigationIndex]

            n=self.leftText.tag_names("%d.0" % a)
            n=list(filter(lambda x: x != "sel" and x != "highlight",n))
            assert len(n) == 1
            t="dark"+n[0]
            if t == "darkbluediffchar":
                t="darkblue"

            self.leftText.tag_config("highlight",background=t,foreground="white")
            self.rightText.tag_config("highlight",background=t,foreground="white")

            self.leftText.tag_remove("highlight",1.0,tk.END)
            self.rightText.tag_remove("highlight",1.0,tk.END)

            self.leftText.tag_add("highlight","%d.0" % a,"%d.0" % b)
            self.rightText.tag_add("highlight","%d.0" % a,"%d.0" % b)

            x = 0
            y = 0
            if t == "darkblue":
                leftString = self.leftData[a-1][0]
                rightString = self.rightData[a-1][0]
                xdleft, ydleft, xdright, ydright = self.oneLineDiff(leftString, rightString)
                x = xdleft
                y = ydleft

            if self.leftText.bbox("%d.%d" % (b,x)) is None or self.leftText.bbox("%d.%d" % (a,x)) is None:
                self.verticalScrollbarUpdateInfo = 40
                self.horizontalScrollbarUpdateInfo = 40
                if direction == 1:
                    self.leftText.see("%d.%d" % (min(b+10000, self.totalLines), x))
                    self.rightText.see("%d.%d" % (min(b+10000, self.totalLines), x))
                    self.leftText.see("%d.%d" % (a, x))
                    self.rightText.see("%d.%d" % (a, x))
                elif direction == -1:
                    self.leftText.see("%d.%d" % (max(a-10000, 0), x))
                    self.rightText.see("%d.%d" % (max(a-10000, 0), x))
                    self.leftText.see("%d.%d" % (b, x))
                    self.rightText.see("%d.%d" % (b, x))
                self.mainFrame.update_idletasks()
                self.verticalScrollbarUpdateInfo = 10
                self.horizontalScrollbarUpdateInfo = 10

            if self.navigationIndex==0:
                self.buttonFirstDiff.config(state=tk.DISABLED)
                self.buttonPreviousDiff.config(state=tk.DISABLED)
            else:
                self.buttonFirstDiff.config(state=tk.NORMAL)
                self.buttonPreviousDiff.config(state=tk.NORMAL)

            if self.navigationIndex>=len(self.navigationList)-1:
                self.buttonLastDiff.config(state=tk.DISABLED)
                self.buttonNextDiff.config(state=tk.DISABLED)
            else:
                self.buttonLastDiff.config(state=tk.NORMAL)
                self.buttonNextDiff.config(state=tk.NORMAL)

    def onFileExit(self):
        self.quit()
        self.master.destroy()

    def findAction(self):
        if self.findIgnoreCase:
            actualFindString=self.findString.upper()
        else:
            actualFindString=self.findString

        # Take current start position for find/search from
        #     - current selection
        #     - current insertion cursor
        #     - begin (or end for backward search) of file

        selectionRange = self.findTextWidget.tag_ranges(tk.SEL)
        if len(selectionRange) == 0:
            insertIndex = self.findTextWidget.index(tk.INSERT)
            if insertIndex != self.findTextWidget.index("%s-1c" % tk.END):
                # insert-index available
                newFindIndex = insertIndex
            else:
                # insert-index not available
                if self.findDirection == 1: # forward search
                    newFindIndex = "1.0"
                else:  # backward search
                    newFindIndex = self.findTextWidget.index(tk.END)
        else:
            if self.findDirection == 1:
                # forward search
                newFindIndex = selectionRange[0]
                newFindIndex = self.findTextWidget.index("%s+1c" % selectionRange[0])
            else:
                # backward search
                newFindIndex = selectionRange[1]
                newFindIndex = self.findTextWidget.index("%s-1c" % selectionRange[1])

        if self.findDirection == 1:
            # forward search
            findData = self.findTextWidget.get(newFindIndex,tk.END)
        else:
            # backward search
            findData = self.findTextWidget.get("1.0",newFindIndex)

        if self.findIgnoreCase:
            findData = findData.upper()

        if self.findDirection == 1:
            distance = findData.find(actualFindString)
        else:
            distance = findData.rfind(actualFindString)

        if distance >= 0:
            if self.findDirection == 1:
                newFindIndex = self.findTextWidget.index("%s+%dc" % (newFindIndex, distance))
            else:
                newFindIndex = self.findTextWidget.index("%s+%dc" % ("1.0", distance))
            beginSelectionIndex = newFindIndex
            endSelectionIndex = self.findTextWidget.index("%s+%sc" % (newFindIndex, len(actualFindString)))
            self.leftText.tag_remove(tk.SEL, 1.0, tk.END)
            self.rightText.tag_remove(tk.SEL, 1.0, tk.END)

            # The widget must have focus (on Windows platform),
            # otherwise tag SEL is ignored.
            self.findTextWidget.focus()
            self.findTextWidget.tag_add(tk.SEL,beginSelectionIndex,endSelectionIndex)
            self.findTextWidget.mark_set(tk.INSERT,endSelectionIndex)

            if (self.findTextWidget.bbox(beginSelectionIndex) is None or
                    self.findTextWidget.bbox(endSelectionIndex) is None):
                if self.findDirection == 1:
                    line,col=beginSelectionIndex.split(".")
                    self.findTextWidget.see("%d.%d" %
                            (min(int(line)+10000,self.totalLines),
                             int(col)))
                    self.findTextWidget.see(endSelectionIndex)
                    self.findTextWidget.see(beginSelectionIndex)
                elif self.findDirection == -1:
                    line,col=endSelectionIndex.split(".")
                    self.findTextWidget.see("%d.%d" %
                            (min(int(line)-10000,self.totalLines),
                             int(col)))
                    self.findTextWidget.see(beginSelectionIndex)
                    self.findTextWidget.see(endSelectionIndex)
        else:
            MessageDialog(self.master,
                    "Not found",
                    self.findString+" not found in "+self.findInWhatWindow+" window.")


    def onViewFind(self, event=None):
        dialog=FindDialog(self.master, defaultFindString=self.findString)
        if dialog.findString is not None:
            self.findString = dialog.findString
        # Do not modify self.findString if "Cancel" was pressed in FindDialog.
        if dialog.findString is not None and self.findString != "":
            self.findInWhatWindow = dialog.findInWhatWindow.get()
            self.findIgnoreCase = dialog.findIgnoreCase.get()
            if self.findInWhatWindow=="right":
                self.findData=self.rightData
                self.findTextWidget = self.rightText
            else:
                self.findData=self.leftData
                self.findTextWidget = self.leftText
            self.findDirection = dialog.findDirection.get()
            if self.findDirection == 1:   # find forward
                self.currentFindLine = 0
            else:
                self.currentFindLine = self.totalLines-1
            self.findAction()

    def onViewFindAgain(self, dummyEvent=None):
        if self.findString is None or self.findString == "":
            self.onViewFind()
        else:
            self.currentFindLine=self.currentFindLine+self.findDirection
            self.findAction()

    def createPopupMenus(self):
        self.standardEditor = os.environ.get("EDITOR","").strip()
        self.leftPopupMenu = tk.Menu(tearoff=0)
        self.rightPopupMenu = tk.Menu(tearoff=0)
        if self.standardEditor != "":
            self.leftPopupMenu.add_command(
                    label="Edit ("+self.standardEditor+") left file",
                    command=self.editLeftFile)
            self.rightPopupMenu.add_command(
                    label="Edit ("+self.standardEditor+") right file",
                    command=self.editRightFile)
        if os.name == "nt":
            self.leftPopupMenu.add_command(label="Notepad",command=self.notepadLeftFile)
            self.rightPopupMenu.add_command(label="Notepad",command=self.notepadRightFile)
            self.leftPopupMenu.add_command(label="Wordpad",command=self.wordpadLeftFile)
            self.rightPopupMenu.add_command(label="Wordpad",command=self.wordpadRightFile)
        else:
            self.leftPopupMenu.add_command(label="nedit", command=self.neditLeftFile)
            self.leftPopupMenu.add_command(label="xemacs", command=self.xemacsLeftFile)
            self.leftPopupMenu.add_command(label="vi", command=self.viLeftFile)
            self.rightPopupMenu.add_command(label="nedit", command=self.neditRightFile)
            self.rightPopupMenu.add_command(label="xemacs", command=self.xemacsRightFile)
            self.rightPopupMenu.add_command(label="vi", command=self.viRightFile)

    def popupLeftMenu(self, event):
        self.unpostContextMenus()
        self.leftPopupMenu.post(event.x_root, event.y_root)

    def popupRightMenu(self, event):
        self.unpostContextMenus()
        self.rightPopupMenu.post(event.x_root, event.y_root)

    def unpostContextMenus(self, event=None):
        self.leftPopupMenu.unpost()
        self.rightPopupMenu.unpost()

    def startEditor(self,editor,file):
        cmd = editor + " " + file + " &"
        rc = os.system(cmd)
        if rc is not None and rc != 0:
            print("\""+cmd+"\" returned "+str(rc))

    def neditLeftFile(self):
        self.startEditor("nedit", self.filename1)

    def xemacsLeftFile(self):
        self.startEditor("xemacs", self.filename1)

    def viLeftFile(self):
        self.startEditor("xterm -e vi", self.filename1)

    def editLeftFile(self):
        self.startEditor("xterm -e "+self.standardEditor, self.filename1)

    def neditRightFile(self):
        self.startEditor("nedit", self.filename2)

    def xemacsRightFile(self):
        self.startEditor("xemacs", self.filename2)

    def viRightFile(self):
        self.startEditor("xterm -e vi", self.filename2)

    def editRightFile(self):
        self.startEditor("xterm -e "+self.standardEditor, self.filename2)

    def notepadLeftFile(self):
        self.startEditor("notepad", self.filename1)

    def notepadRightFile(self):
        self.startEditor("notepad", self.filename2)

    def wordpadLeftFile(self):
        self.startEditor("write", self.filename1)

    def wordpadRightFile(self):
        self.startEditor("write", self.filename2)

    def filterKey(self, event):
        # Filter all keys which might modify the text.

        #print "sym=<"+ev.keysym+">, code=<"+str(ev.keycode)+">, chr=<"+ev.char+">, state= <"+str(ev.state)+">"

        controlKeyDown = event.state & 4

        if event.keysym in ["Left", "Right", "Up", "Down",
                "Prior", "Next", "Home", "End",
                "Escape", "F3"]:
            return

        if controlKeyDown and event.keysym in [ "f", "c", "x" ]:
            return

        # The event is considered representing a key,
        # which would modify the text, which is not desired.
        return "break"
    
    def viewFiles(self, filename1, filename2):
        self.filename1 = filename1
        self.filename2 = filename2

        with open(self.filename1) as stream:
            self.leftLines = stream.readlines()

        with open(self.filename2) as stream:
            self.rightLines  = stream.readlines()

        self.leftLabel.insert(tk.END, self.filename1)
        self.leftData=[[line, None] for line in self.leftLines]

        self.rightLabel.insert(tk.END, self.filename2)
        self.rightData=[[line, None] for line in self.rightLines]

        self.setDiffRecords()
        
        numberOfDifferences = len(self.diffRecords)
        if numberOfDifferences == 0:
            message="No differences found."
        elif numberOfDifferences == 1:
            message="1 difference found."
        else:
            message= f"{numberOfDifferences} differences found."
        self.quietPrint(message)
        self.setStatus(message)

        self.diffRecords.reverse()

        # First traversal does not modify the diffRecords.
        for t, a1, a2, b1, b2 in self.diffRecords:
            if t == "a":
                # Something that only exists on the right side.
                assert a1==a2
                assert b1<=b2
                i = b1
                while i <= b2:
                    self.rightData[i-1][1] = "green"
                    i = i + 1

            if t=="d":
                # Something that only exists on the left side.
                assert b1==b2
                assert a1<=a2
                i=a1
                while i<=a2:
                    self.leftData[i-1][1]="red"
                    i = i + 1

            if t=="c":
                # Something that exists on both sides.
                assert a1<=a2
                assert b1<=b2
                i=a1
                while i<=a2:
                    self.leftData[i-1][1]="blue"
                    i = i + 1
                i=b1
                while i<=b2:
                    self.rightData[i-1][1]="blue"
                    i = i + 1

        # Second traversal adds the added and deleted fragments.
        for t, a1, a2, b1, b2 in self.diffRecords:
            if t=="a":
                    # Something that only exists on the right side.
                    assert a1==a2
                    assert b1<=b2
                    i = b1
                    while i<=b2:
                        self.leftData.insert(a1,["\n","green"])
                        i=i+1
            if t=="d":
                    # Something that only exists on the left side.
                    assert b1==b2
                    assert a1<=a2
                    i=a1
                    while i<=a2:
                        self.rightData.insert(b1,["\n","red"])
                        i=i+1
            if t=="c":
                    # Something that changed between the two sides.
                    assert a1<=a2
                    assert b1<=b2
                    if a2-a1 < b2-b1:
                        i=b1+a2-a1
                        while i<b2:
                            self.leftData.insert(a2,["\n","blue"])
                            i=i+1
                    elif a2-a1 > b2-b1:
                        i=a1+b2-b1
                        while i<a2:
                            self.rightData.insert(b2,["\n","blue"])
                            i=i+1

        self.diffRecords.reverse()   # For canvasChanged in ascending order.

        lineNumber=1
        oldTag=None
        a=None
        b=None
        for x,t in self.leftData+[("Dummy", None)]:
            if t != oldTag:
                if a is not None:
                    b=lineNumber
                    self.navigationList.append((a,b,oldTag))
                if t is None:
                    a=None
                else:
                    a=lineNumber
            oldTag=t
            lineNumber=lineNumber+1

        self.totalLines=lineNumber-2

        self.linesLabel.config(text="Total lines: %d" % self.totalLines)

        self.leftText.tag_config("red", background="pink")
        self.leftText.tag_config("green", background="lightgreen")
        self.leftText.tag_config("blue", background="lightblue")
        self.leftText.tag_config("highlight", background="black", foreground="white")
        # diffchar tag must be created after highlight tag in order to have priority
        # (still be visible when highlighted)
        self.leftText.tag_config("bluediffchar",
                background="red",
                foreground="white",
                relief=tk.GROOVE)
        self.leftText.tag_raise(tk.SEL)  # SEL overrides all other tags
        self.leftText.tag_config(tk.SEL, background="black", foreground="white")

        self.rightText.tag_config("red", background="pink")
        self.rightText.tag_config("green", background="lightgreen")
        self.rightText.tag_config("blue", background="lightblue")
        self.rightText.tag_config("highlight", background="black", foreground="white")
        # diffchar tag must be created after highlight tag in order to have priority
        self.rightText.tag_config("bluediffchar",
                background="red",
                foreground="white",
                relief=tk.GROOVE)
        self.rightText.tag_raise(tk.SEL)  # SEL overrides all other tags
        self.rightText.tag_config(tk.SEL, background="black", foreground="white")

        assert len(self.leftData) == self.totalLines
        assert len(self.rightData) == self.totalLines

        lineNumber=0
        while lineNumber<self.totalLines:
            leftLine,leftTag=self.leftData[lineNumber]
            rightLine,rightTag=self.rightData[lineNumber]
            assert leftTag==rightTag
            if (leftTag == "blue" and
                leftLine != "" and leftLine != "\n" and
                rightLine != "" and rightLine != "\n"):
                xdleft, ydleft, xdright, ydright = self.oneLineDiff(leftLine, rightLine)
                # xdleft points now to the first different character of the line
                # ydleft points to first different character from the end
                self.leftText.insert(tk.END, leftLine[:xdleft], "blue")
                self.leftText.insert(tk.END, leftLine[xdleft:len(leftLine)-ydleft], "bluediffchar")
                self.leftText.insert(tk.END, leftLine[len(leftLine)-ydleft:], "blue")
                self.rightText.insert(tk.END, rightLine[:xdright], "blue")
                self.rightText.insert(tk.END, rightLine[xdright:len(rightLine)-ydright], "bluediffchar")
                self.rightText.insert(tk.END, rightLine[len(rightLine)-ydright:], "blue")
            else:
                self.leftText.insert(tk.END, leftLine, leftTag)
                self.rightText.insert(tk.END, rightLine, rightTag)
            lineNumber=lineNumber+1

        self.navigateToIndex()

    def normalize(self, str):
        if self.ignoreAllBlanks:
            return ' '.join(str.split())
        if self.ignoreTrailingBlanks:
            return str.rstrip()
        return str

    def setDiffRecords(self):
        self.diffRecords = []
        left = [self.normalize(line) for line in self.leftLines]
        right = [self.normalize(line) for line in self.rightLines]
        matcher = difflib.SequenceMatcher(None, left, right)
        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == "replace":
                self.diffRecords.append(("c", i1+1, i2, j1+1, j2))
            elif tag == "delete":
                self.diffRecords.append(("d", i1+1, i2, j1, j1))
            elif tag == "insert":
                self.diffRecords.append(("a", i1, i1, j1+1, j2))

    def first_diff(self, a, b):
        assert (a != b)
        for i in range(min(len(a),len(b))):
            if a[i] != b[i]:
                return i
            i = i + 1
        return i

    def last_diff(self, a, b):
        return self.first_diff(a[::-1], b[::-1])

    def splitTrailingBlanks(self, str):
        i = -1 
        while str[i].isspace():
            i -= 1
        result = str[:i+1], str[i+1:]
        return result

    def splitChunks(self, str):
        return re.findall(r'\s+|\S+', str)
    
    def linesAreEqual(self, leftLine, rightLine):
        if self.ignoreAllBlanks:
            return leftLine.split() == rightLine.split()
        elif self.ignoreTrailingBlanks:
            leftContent, leftBlanks = self.splitTrailingBlanks(leftLine)
            rightContent, rightBlanks = self.splitTrailingBlanks(rightLine)
            return leftContent == rightContent
        else:
            return leftLine == rightLine

    def indexesOfFirstDifferentCharacter(self, leftLine, rightLine):
        assert self.ignoreAllBlanks
        leftChunks = self.splitChunks(leftLine)
        rightChunks = self.splitChunks(rightLine)
        leftIndex = 0
        rightIndex = 0
        firstDifferentLeft = 0
        firstDifferentRight = 0
        if leftChunks[leftIndex].isspace():
            firstDifferentLeft += len(leftChunks[leftIndex])
            leftIndex = leftIndex+1
        if rightChunks[rightIndex].isspace():
            firstDifferentRight += len(rightChunks[rightIndex])
            rightIndex = rightIndex+1
        while True:
            if leftIndex >= len(leftChunks)-1 or rightIndex > len(rightChunks)-1:
                break
            leftChunk = leftChunks[leftIndex]
            rightChunk = rightChunks[rightIndex]
            if leftChunk.isspace():
                leftChunk = ' '
            if rightChunk.isspace():
                rightChunk = ' '
            if leftChunk == rightChunk:
                firstDifferentLeft += len(leftChunks[leftIndex])
                leftIndex += 1
                firstDifferentRight += len(rightChunks[rightIndex])
                rightIndex += 1
            else:
                i = self.first_diff(leftChunks[leftIndex], rightChunks[rightIndex])
                firstDifferentLeft += i
                firstDifferentRight += i
                break
        return firstDifferentLeft, firstDifferentRight

    def indexesOfLastDifferentCharacter(self, leftLine, rightLine):
        return self.indexesOfFirstDifferentCharacter(leftLine[::-1]+'\n', rightLine[::-1]+'\n')

    def oneLineDiff(self, leftLine, rightLine):
        if self.ignoreAllBlanks:
            if self.linesAreEqual(leftLine, rightLine):
                return 0, 0, 0, 0
            firstDifferentLeft, firstDifferentRight = self.indexesOfFirstDifferentCharacter(leftLine, rightLine)
            lastDifferentLeft, lastDifferentRight = self.indexesOfLastDifferentCharacter(leftLine, rightLine)
            return firstDifferentLeft, lastDifferentLeft, firstDifferentRight, lastDifferentRight
        elif self.ignoreTrailingBlanks:
            if self.linesAreEqual(leftLine, rightLine):
                return 0, 0, 0, 0
            leftContent, leftBlanks = self.splitTrailingBlanks(leftLine)
            rightContent, rightBlanks = self.splitTrailingBlanks(rightLine)
            if leftContent == rightContent:
                return 0, 0 ,0 ,0
            first = self.first_diff(leftContent, rightContent)
            last = self.last_diff(leftContent, rightContent)
            return first, last+len(leftBlanks), first, last+len(rightBlanks)
        else:
            if self.linesAreEqual(leftLine, rightLine):
                return 0, 0, 0, 0
            first = self.first_diff(leftLine, rightLine)
            last = self.last_diff(leftLine[first:], rightLine[first:])
            return first, last, first, last

class DiffTool:
    def __init__(self):
        self.filename1 = None
        self.filename2 = None
        self.ignoreAllBlanks = False 
        self.ignoreTrailingBlanks = False 

    def usage(self, *arguments):
        warn(*arguments)
        warn("xdiff: diff two files")
        warn("Usage: xdiff [ options ] file1 file2")
        warn("    -w    ignore all blanks")
        warn("    -b    ignore trailing blanks")
        sys.exit(2)

    def processCommandLine(self):
        try:
            self.processArguments(sys.argv[1:])
        except KeyboardInterrupt:
            print('Interrupted ...')
            # 130 is the standard Unix exit code for a program
            # terminated by SIGINT (Ctrl-C): 128 + signal number 2.
            sys.exit(130)

    def processArguments(self, arguments):
        try:
            options, arguments = getopt.getopt(arguments, 'bw')
        except getopt.GetoptError as exception:
            error(exception)

        for key, value in options:
            if key == '-w':
                self.ignoreAllBlanks = True 
            elif key == '-b':
                self.ignoreTrailingBlanks = True 
            else:
                error('unexpected command line option', key)
        if len(arguments) < 2:
            self.usage("Two file names expected.")
        elif len(arguments) > 2:
            self.usage("Too many parameters.")
        else:
            self.filename1, self.filename2 = arguments
            self.processFiles()

    def processFiles(self):
        if not os.path.exists(self.filename1):
            error(self.filename1, 'not found.')
        if not os.path.exists(self.filename2):
            error(self.filename2, 'not found.')
        if os.path.isdir(self.filename1):
            if os.path.isdir(self.filename2):
                self.processDirectories()
            elif os.path.isfile(self.filename2):
                self.processRegularFiles(
                        os.path.join(self.filename1, os.path.basename(self.filename2)),
                        self.filename2)
            else:
                error(self.filename2, 'is not a regular file or a directory.')
        elif os.path.isfile(self.filename1):
            if os.path.isdir(self.filename2):
                self.processRegularFiles(
                        self.filename1,
                        os.path.join(self.filename2, os.path.basename(self.filename1)))
                self.processRegularFiles()
            elif os.path.isfile(self.filename2):
                self.processRegularFiles(self.filename1, self.filename2)
            else:
                error(self.filename2, 'is not a regular file or a directory.')
        else:
            error(self.filename1, 'is not a regular file or a directory.')

    def processDirectories(self):
        if self.areFilesIdentical():
            warn('The directories are identical.')
            return 

        dir1 = self.filename1
        dir2 = self.filename2

        for root1, dirs1, files1 in os.walk(dir1):
            rel_path = os.path.relpath(root1, dir1)
            root2 = os.path.join(dir2, rel_path)

            # Compare files
            for f in files1:
                path1 = os.path.normpath(os.path.join(root1, f))
                path2 = os.path.normpath(os.path.join(root2, f))
                if os.path.exists(path2):
                    if filecmp.cmp(path1, path2, shallow=False):
                        print(f"Same: {path1}")
                    else:
                        print(f"Different: {path1}")
                        self.processRegularFiles(path1, path2)
                else:
                    print(f"Only in dir1: {path1}")

            # Check for files only in dir2
            if os.path.exists(root2):
                for f in os.listdir(root2):
                    path2 = os.path.normpath(os.path.join(root2, f))
                    path1 = os.path.normpath(os.path.join(root1, f))
                    if f not in files1 and os.path.isfile(path2):
                        print(f"Only in dir2: {path2}")


    def processRegularFiles(self, leftFilename, rightFilename):
        if not os.path.exists(self.filename1):
            error(self.filename1, 'not found.')
        if not os.path.exists(self.filename2):
            error(self.filename2, 'not found.')
        if self.areFilesIdentical():
            warn('The files are identical.')
            return 
        try:
            root = tk.Tk()
        except tk.TclError as exception:
            print(exception)
            sys.exit(2)

        root.title("xdiff")

        self.viewer = DiffViewer(root)
        self.viewer.quietMode = True
        self.viewer.ignoreTrailingBlanks = self.ignoreTrailingBlanks
        self.viewer.ignoreAllBlanks = self.ignoreAllBlanks
        self.viewer.viewFiles(leftFilename, rightFilename)

        self.myMainLoop(root)

    def myMainLoop(self, root):
        # Simulate mainloop with instant response for Ctrl-C
        # Replaces root.mainloop() which is slow to react on Ctrl-C
        try:
            while root.winfo_exists():
                root.update_idletasks()
                root.update()   
                time.sleep(0.3)        
        except tk.TclError:
            pass


    def areFilesIdentical(self):
        stat1 = os.stat(self.filename1)
        stat2 = os.stat(self.filename2)
        return stat1.st_dev == stat2.st_dev and stat1.st_ino == stat2.st_ino

if __name__ == "__main__":
    DiffTool().processCommandLine()


